class ScreenSpecBackground {
    constructor() {
        this.init();
    }

    init() {
        // „É°„ÉÉ„Çª„Éº„Ç∏„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            this.handleMessage(message, sender, sendResponse);
            return true; // ÈùûÂêåÊúü„É¨„Çπ„Éù„É≥„Çπ„ÇíÊúâÂäπ„Å´„Åô„Çã
        });

        // „Ç§„É≥„Çπ„Éà„Éº„É´ÊôÇ„ÅÆÂàùÊúüÂåñ
        chrome.runtime.onInstalled.addListener(() => {
            this.onInstalled();
        });
    }

    onInstalled() {
        console.log('ScreenSpec „Åå„Ç§„É≥„Çπ„Éà„Éº„É´„Åï„Çå„Åæ„Åó„Åü');
        
        // ÂàùÊúü„Éá„Éº„ÇøÊßãÈÄ†„ÇíË®≠ÂÆö
        chrome.storage.local.get(['screens'], (result) => {
            if (!result.screens) {
                chrome.storage.local.set({ screens: [] });
            }
        });
    }

    async handleMessage(message, sender, sendResponse) {
        try {
            switch (message.action) {
                case 'fullPageCaptured':
                    await this.handleFullPageCapture(message, sender);
                    break;
                
                case 'captureError':
                    this.handleCaptureError(message, sender);
                    break;
                
                case 'exportPDF':
                    await this.handlePDFExport(message);
                    break;
                
                case 'saveAnnotations':
                    await this.handleSaveAnnotations(message, sendResponse);
                    break;
                
                default:
                    console.log('Unknown message action:', message.action);
            }
        } catch (error) {
            console.error('Background script error:', error);
        }
    }

    async handleSaveAnnotations(message, sendResponse) {
        try {
            const { screens = [] } = await chrome.storage.local.get(['screens']);
            const screenIndex = screens.findIndex(s => s.id === message.screenId);
            
            if (screenIndex !== -1) {
                screens[screenIndex].annotations = message.annotations;
                screens[screenIndex].lastModified = new Date().toISOString();
                
                // „É°„ÇøÊÉÖÂ†±„Çí‰øùÂ≠ò
                if (message.metadata) {
                    screens[screenIndex].metadata = {
                        ...screens[screenIndex].metadata,
                        ...message.metadata
                    };
                }
                
                await chrome.storage.local.set({ screens });
                
                console.log('Ê≥®Èáà„Å®„É°„ÇøÊÉÖÂ†±„Åå‰øùÂ≠ò„Åï„Çå„Åæ„Åó„Åü:', message.screenId);
                sendResponse({ success: true });
            } else {
                console.error('ÁîªÈù¢„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì:', message.screenId);
                sendResponse({ success: false, error: 'Screen not found' });
            }
        } catch (error) {
            console.error('Ê≥®Èáà‰øùÂ≠ò„Ç®„É©„Éº:', error);
            sendResponse({ success: false, error: error.message });
        }
    }

    async handleFullPageCapture(message, sender) {
        try {
            const screenData = {
                id: Date.now().toString(),
                dataUrl: message.dataUrl,
                url: message.url,
                title: message.title,
                timestamp: new Date().toISOString(),
                annotations: [],
                metadata: {
                    screenName: '',
                    functionName: '',
                    author: '',
                    description: ''
                }
            };

            // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
            const { screens = [] } = await chrome.storage.local.get(['screens']);
            screens.push(screenData);
            await chrome.storage.local.set({ screens });

            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å´ÈÄöÁü•ÔºàÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥ÂêàÔºâ
            try {
                chrome.runtime.sendMessage({
                    action: 'captureComplete',
                    screenData: screenData
                });
            } catch (e) {
                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÈñã„ÅÑ„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„Ç®„É©„Éº„ÇíÁÑ°Ë¶ñ
            }

            // ÊàêÂäüÈÄöÁü•
            chrome.notifications.create({
                type: 'basic',
                iconUrl: 'icons/icon48.png',
                title: 'ScreenSpec',
                message: '„Éï„É´„Éö„Éº„Ç∏„Ç≠„É£„Éó„ÉÅ„É£„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü'
            });

        } catch (error) {
            console.error('„Éï„É´„Éö„Éº„Ç∏„Ç≠„É£„Éó„ÉÅ„É£Âá¶ÁêÜ„Ç®„É©„Éº:', error);
        }
    }

    handleCaptureError(message, sender) {
        console.error('„Ç≠„É£„Éó„ÉÅ„É£„Ç®„É©„Éº:', message.error);
        
        chrome.notifications.create({
            type: 'basic',
            iconUrl: 'icons/icon48.png',
            title: 'ScreenSpec - „Ç®„É©„Éº',
            message: '„Ç≠„É£„Éó„ÉÅ„É£„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + message.error
        });
    }

    async handlePDFExport(message) {
        try {
            const screens = message.screens;
            
            if (!screens || screens.length === 0) {
                throw new Error('Êõ∏„ÅçÂá∫„ÅôÁîªÈù¢„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
            }

            console.log('üìÑ Starting simplified PDF generation for', screens.length, 'screens');

            // Á∞°Á¥†Âåñ„Åï„Çå„ÅüPDFÁîüÊàê
            const htmlContent = this.generateHTMLReport(screens);
            
            // HTML„ÇíBlob„Å®„Åó„Å¶„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÔºàPDF‰ª£ÊõøÔºâ
            const blob = new Blob([htmlContent], { type: 'text/html; charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            // „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„ÇíÂÆüË°å
            const timestamp = new Date().toISOString().split('T')[0];
            await chrome.downloads.download({
                url: url,
                filename: `ScreenSpecË®≠Ë®àÊõ∏_${timestamp}.html`,
                saveAs: true
            });

            // ÊàêÂäüÈÄöÁü•
            chrome.notifications.create({
                type: 'basic',
                iconUrl: 'icons/icon48.png',
                title: 'ScreenSpec',
                message: 'üìÑ HTMLË®≠Ë®àÊõ∏„ÅÆÊõ∏„ÅçÂá∫„Åó„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ„Éñ„É©„Ç¶„Ç∂„ÅßÈñã„ÅÑ„Å¶PDFÂç∞Âà∑„Åß„Åç„Åæ„Åô„ÄÇ'
            });

            // URL„ÇíËß£Êîæ
            setTimeout(() => URL.revokeObjectURL(url), 1000);

        } catch (error) {
            console.error('‚ùå PDFÊõ∏„ÅçÂá∫„Åó„Ç®„É©„Éº:', error);
            
            chrome.notifications.create({
                type: 'basic',
                iconUrl: 'icons/icon48.png',
                title: 'ScreenSpec - „Ç®„É©„Éº',
                message: 'PDFÊõ∏„ÅçÂá∫„Åó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message
            });
        }
    }

    generateHTMLReport(screens) {
        const totalAnnotations = screens.reduce((sum, screen) => sum + (screen.annotations?.length || 0), 0);
        const authors = [...new Set(screens.map(s => s.metadata?.author).filter(a => a))];
        const now = new Date();
        
        let html = `
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScreenSpec Ë®≠Ë®àÊõ∏</title>
    <style>
        body {
            font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Noto Sans CJK JP', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f9f9f9;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .cover {
            text-align: center;
            border-bottom: 2px solid #007bff;
            padding-bottom: 30px;
            margin-bottom: 40px;
        }
        .cover h1 {
            font-size: 2.5em;
            color: #007bff;
            margin-bottom: 20px;
        }
        .cover .stats {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            display: inline-block;
        }
        .toc {
            margin-bottom: 40px;
        }
        .toc h2 {
            color: #007bff;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
        }
        .toc-item {
            padding: 10px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        .screen-section {
            margin: 40px 0;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
        }
        .screen-header {
            background: #007bff;
            color: white;
            padding: 20px;
        }
        .screen-content {
            padding: 30px;
        }
        .screen-image {
            max-width: 100%;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .metadata {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .metadata-item {
            margin: 5px 0;
        }
        .tag {
            background: #e9ecef;
            color: #495057;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.9em;
            margin-right: 5px;
        }
        @media print {
            body { background: white; }
            .container { box-shadow: none; }
            .screen-section { page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Ë°®Á¥ô -->
        <div class="cover">
            <h1>üìã ScreenSpec Ë®≠Ë®àÊõ∏</h1>
            <div class="stats">
                <div><strong>üìÖ ‰ΩúÊàêÊó•:</strong> ${now.toLocaleDateString('ja-JP')}</div>
                <div><strong>üìä Á∑èÁîªÈù¢Êï∞:</strong> ${screens.length}ÁîªÈù¢</div>
                <div><strong>üé® Á∑èÊ≥®ÈáàÊï∞:</strong> ${totalAnnotations}ÂÄã</div>
                ${authors.length > 0 ? `<div><strong>üë§ ‰ΩúÊàêËÄÖ:</strong> ${authors.join(', ')}</div>` : ''}
            </div>
        </div>

        <!-- ÁõÆÊ¨° -->
        <div class="toc">
            <h2>üìë ÁõÆÊ¨°</h2>
            ${screens.map((screen, index) => {
                const title = screen.metadata?.screenName || screen.title || `ÁîªÈù¢ ${index + 1}`;
                const functionName = screen.metadata?.functionName || '';
                return `
                    <div class="toc-item">
                        <strong>${index + 1}. ${title}</strong>
                        ${functionName ? `<br><small style="color: #666;">‚öôÔ∏è ${functionName}</small>` : ''}
                    </div>
                `;
            }).join('')}
        </div>

        <!-- ÁîªÈù¢Ë©≥Á¥∞ -->
        ${screens.map((screen, index) => {
            const title = screen.metadata?.screenName || screen.title || `ÁîªÈù¢ ${index + 1}`;
            const metadata = screen.metadata || {};
            const createdDate = new Date(screen.timestamp).toLocaleDateString('ja-JP');
            const modifiedDate = screen.lastModified ? new Date(screen.lastModified).toLocaleDateString('ja-JP') : null;
            const annotationCount = screen.annotations?.length || 0;
            
            return `
                <div class="screen-section">
                    <div class="screen-header">
                        <h2>${index + 1}. ${title}</h2>
                    </div>
                    <div class="screen-content">
                        <div class="metadata">
                            ${metadata.functionName ? `<div class="metadata-item"><strong>‚öôÔ∏è Ê©üËÉΩ:</strong> ${metadata.functionName}</div>` : ''}
                            ${metadata.author ? `<div class="metadata-item"><strong>üë§ ‰ΩúÊàêËÄÖ:</strong> ${metadata.author}</div>` : ''}
                            ${metadata.tags ? `<div class="metadata-item"><strong>üè∑Ô∏è „Çø„Ç∞:</strong> ${metadata.tags.split(',').map(tag => `<span class="tag">${tag.trim()}</span>`).join('')}</div>` : ''}
                            <div class="metadata-item"><strong>üìÖ ‰ΩúÊàêÊó•:</strong> ${createdDate}</div>
                            ${modifiedDate && modifiedDate !== createdDate ? `<div class="metadata-item"><strong>üîÑ Êõ¥Êñ∞Êó•:</strong> ${modifiedDate}</div>` : ''}
                            <div class="metadata-item"><strong>üé® Ê≥®ÈáàÊï∞:</strong> ${annotationCount}ÂÄã</div>
                        </div>
                        
                        ${screen.dataUrl ? `<img src="${screen.dataUrl}" alt="${title}" class="screen-image">` : '<p style="color: #666;">ÁîªÂÉè„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p>'}
                        
                        ${metadata.description ? `
                            <div style="margin-top: 20px;">
                                <h4>üìù Ë™¨Êòé</h4>
                                <p style="background: #f8f9fa; padding: 15px; border-radius: 4px; white-space: pre-wrap;">${metadata.description}</p>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join('')}

        <!-- „Éï„ÉÉ„Çø„Éº -->
        <div style="text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #dee2e6; color: #666;">
            <small>Generated by ScreenSpec v1.0.0 - ${now.toLocaleString('ja-JP')}</small>
        </div>
    </div>
</body>
</html>`;
        
        return html;
    }

    generatePDFData(screens) {
        // Á∞°ÊòìÁöÑ„Å™PDF„Éá„Éº„ÇøÁîüÊàê
        // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØjsPDF„É©„Ç§„Éñ„É©„É™„Çí‰ΩøÁî®
        let pdfContent = `%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] >>
endobj
xref
0 4
0000000000 65535 f 
0000000010 00000 n 
0000000053 00000 n 
0000000103 00000 n 
trailer
<< /Size 4 /Root 1 0 R >>
startxref
167
%%EOF`;

        return pdfContent;
    }

    // „Çø„Éñ„ÅåÊõ¥Êñ∞„Åï„Çå„ÅüÊôÇ„ÅÆÂá¶ÁêÜ
    handleTabUpdate(tabId, changeInfo, tab) {
        if (changeInfo.status === 'complete') {
            // content script„Å´Ë®≠ÂÆö„ÅÆÂêåÊúü„Å™„Å©„ÇíË°å„ÅÜÂ†¥Âêà
        }
    }

    // „Çπ„Éà„É¨„Éº„Ç∏„ÅÆÁÆ°ÁêÜ
    async cleanupOldData() {
        try {
            const { screens = [] } = await chrome.storage.local.get(['screens']);
            
            // 30Êó•‰ª•‰∏äÂè§„ÅÑ„Éá„Éº„Çø„ÇíÂâäÈô§
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            
            const recentScreens = screens.filter(screen => {
                const screenDate = new Date(screen.timestamp);
                return screenDate > thirtyDaysAgo;
            });

            if (recentScreens.length !== screens.length) {
                await chrome.storage.local.set({ screens: recentScreens });
                console.log(`${screens.length - recentScreens.length}‰ª∂„ÅÆÂè§„ÅÑ„Éá„Éº„Çø„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü`);
            }
        } catch (error) {
            console.error('„Éá„Éº„Çø„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„Ç®„É©„Éº:', error);
        }
    }
}

// „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Çπ„ÇØ„É™„Éó„ÉàÂàùÊúüÂåñ
const screenSpecBackground = new ScreenSpecBackground();

// ÂÆöÊúüÁöÑ„Å™„Éá„Éº„Çø„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÔºà1Êó•1ÂõûÔºâ
// alarms API„ÅåÂà©Áî®ÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
if (chrome.alarms) {
    chrome.alarms.create('dataCleanup', { delayInMinutes: 1440, periodInMinutes: 1440 });
    chrome.alarms.onAlarm.addListener((alarm) => {
        if (alarm.name === 'dataCleanup') {
            screenSpecBackground.cleanupOldData();
        }
    });
} else {
    console.log('Alarms API is not available');
}